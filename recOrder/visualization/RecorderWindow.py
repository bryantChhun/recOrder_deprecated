# bchhun, {2019-07-29}

from PyQt5.QtCore import pyqtSlot
from PyQt5.QtWidgets import QFileDialog, QWidget
import os
import numpy as np

from ..visualization import VisualizeBase
from ..datastructures import BackgroundData
from .qtdesigner.ReconOrderUI import Ui_ReconOrderUI
from ..microscope.mm2python_simple import snap_and_get_image, py4j_collect_background, py4j_snap_and_correct

from ..analysis.ReconstructOrder import ReconOrder

"""
Ui_ReconOrderUI is generated by qtdesigner.
To generate a new .py file from the designer's .ui file, type this in terminal

pyuic5 -x <.ui input file> -o <.py output file>

"""


"""
A pyqt5 GUI that contains methods for 
"""


class RecorderWindow(VisualizeBase, Ui_ReconOrderUI):

    def __init__(self, win, gateway=None):
        super(RecorderWindow, self).__init__()

        self.setupUi(win)

        # button's signals
        self.qbutton_snap_and_correct.clicked[bool].connect(self.snap_and_correct)
        self.qbutton_collect_background.clicked[bool].connect(self.collect_background)
        self.qbutton_file_browser.clicked[bool].connect(self.file_browser)
        self.start_monitor.clicked[bool].connect(self.launch_monitor)
        self.qbutton_stop_monitor.clicked[bool].connect(self.stop_monitor)

        self.qbutton_calibrate_lc.clicked[bool].connect(self.calibrate)

        # line edit's signals
        self.le_transmission_scale.textChanged[str].connect(self.set_scales)
        self.le_retardance_scale.textChanged[str].connect(self.set_scales)
        self.le_orientation_scale.textChanged[str].connect(self.set_scales)
        self.le_polarization_scale.textChanged[str].connect(self.set_scales)

        self.gate = gateway
        self.gate.entry_point.clearAll()

        # some params
        self.lc_bound = 0.05
        self.swing = float(self.le_swing.text())
        self.I_black = 100
        self.wavelength = int(self.le_wavelength.text())

        # data
        self.Background = BackgroundData()

        self.folderName = "C:\\"

        win.show()

        self.set_scales()

    @pyqtSlot(bool)
    def file_browser(self):
        name = self.open_file_dialog()
        self.le_bg_corr_path.setText(name)

    #TODO: write two dialogs and dialog buttons: one for BG selection, one for directory selection
    def open_file_dialog(self):
        options = QFileDialog.Options()

        options |= QFileDialog.DontUseNativeDialog
        # fileName, _ = QFileDialog.getSaveFileName(None, "QFileDialog.getOpenFileName()", "",
        #                                           "All Files (*);;Python Files (*.py)", options=options)

        self.folderName = QFileDialog.getExistingDirectory(None, 'Select a folder:', self.folderName, QFileDialog.ShowDirsOnly)

        # if fileName:
        #     return fileName

        if self.folderName:
            return self.folderName

    # =============================================================
    # ==================== ReconstructOrder methods ===============

    # because qbutton sends another parameter: bool, we need *args
    @VisualizeBase.emitter(channel=1)
    def snap(self, *args):
        try:
            self.gate.entry_point.clearAll()
            data = snap_and_get_image(self.gate.entry_point)
            return data
        except Exception as ex:
            print("exception during snap\n\t"+str(ex))

    @VisualizeBase.emitter(channel=1)
    def snap_and_correct(self, *args):
        self.log_area.append("calling snap and correct")
        self.gate.entry_point.clearAll()

        # check if a pre-acquired background image is selected
        self.Background = self.load_background_from_files()
        if self.Background is None:
            return None
        else:
            physical_corrected = py4j_snap_and_correct(self.gate, self.Background)
            return physical_corrected

    def load_background_from_files(self):
        STOKES = {'Stokes0': 's0',
                  'Stokes1': 's1',
                  'Stokes2': 's2',
                  'Stokes3': 's3',
                  'Stokes1_norm': 's1_norm',
                  'Stokes2_norm': 's2_norm',
                  'Polarization_norm': 'polarization'}

        if self.folderName:
            for filename in os.listdir(self.folderName):

                # stokes data is present
                if filename.endswith('.npy'):
                    # check for matching STOKES
                    matches = [stk for stk in list(STOKES.keys()) if stk in filename]
                    setattr(self.Background, STOKES[matches[0]], np.load(os.path.join(self.folderName, filename)))

        # check that we have a complete set of stokes values
        if self.Background.s0 is None or self.Background.s1 is None or \
                self.Background.s2 is None or self.Background.s3 is None or self.Background.polarization is None:
            return None
        else:
            return self.Background

    @VisualizeBase.emitter(channel=1)
    def collect_background(self, *args):
        try:
            self.gate.entry_point.clearAll()
            path = None if not self.le_bg_corr_path.text() else self.le_bg_corr_path.text()
            self.Background = py4j_collect_background(self.gate,
                                                      self.Background,
                                                      self.swing,
                                                      self.wavelength,
                                                      self.I_black,
                                                      save_path=path,
                                                      averaging=5)
        except Exception as ex:
            print("exception during collect background \n\t"+str(ex))
            raise AttributeError('exception during collect background')
        return self.Background

    @VisualizeBase.emitter(channel=10)
    def launch_monitor(self, *args):
        # background = self.load_background_from_files()
        # return background
        pass

    @VisualizeBase.emitter(channel=19)
    def stop_monitor(self, *args):
        pass

    def set_scales(self):
        ReconOrder.orientation_scale = float(self.le_orientation_scale.text())
        ReconOrder.polarization_scale = float(self.le_polarization_scale.text())
        ReconOrder.retardance_scale = float(self.le_retardance_scale.text())
        ReconOrder.transmission_scale = float(self.le_transmission_scale.text())

    # =============================================================
    # ================ Calibration methods ========================

    @VisualizeBase.emitter(channel=20)
    def calibrate(self, *args):
        self.gate.entry_point.clearAll()
        self.clear_text_fields()
        return [self.swing, self.wavelength, self.lc_bound, self.I_black]

    # @VisualizeBase.emitter(channel=27)
    # def reset_lc(self, *args):
    #     return None

    def clear_text_fields(self):
        self.le_state0_lca.setText('')
        self.le_state0_lcb.setText('')
        self.le_state1_lca.setText('')
        self.le_state1_lcb.setText('')
        self.le_state2_lca.setText('')
        self.le_state2_lcb.setText('')
        self.le_state3_lca.setText('')
        self.le_state3_lcb.setText('')
        self.le_state4_lca.setText('')
        self.le_state4_lcb.setText('')

        self.le_state0_intensity.setText('')
        self.le_state1_intensity.setText('')
        self.le_state2_intensity.setText('')
        self.le_state3_intensity.setText('')
        self.le_state4_intensity.setText('')

        self.le_extinction.setText('')

    @VisualizeBase.receiver(channel=21)
    def le_state0(self, lc):
        self.le_state0_lca.setText(str(lc[0]))
        self.le_state0_lcb.setText(str(lc[1]))
        self.le_state0_intensity.setText(str(lc[2]))

    @VisualizeBase.receiver(channel=22)
    def le_state1(self, lc):
        self.le_state1_lca.setText(str(lc[1]))
        self.le_state1_lcb.setText(str(lc[2]))
        self.le_state1_intensity.setText(str(lc[0]))

    @VisualizeBase.receiver(channel=23)
    def le_state2(self, lc):
        self.le_state2_lca.setText(str(lc[0]))
        self.le_state2_lcb.setText(str(lc[1]))
        self.le_state2_intensity.setText(str(lc[2]))

    @VisualizeBase.receiver(channel=24)
    def le_state3(self, lc):
        self.le_state3_lca.setText(str(lc[0]))
        self.le_state3_lcb.setText(str(lc[1]))
        self.le_state3_intensity.setText(str(lc[2]))

    @VisualizeBase.receiver(channel=25)
    def le_state4(self, lc):
        self.le_state4_lca.setText(str(lc[0]))
        self.le_state4_lcb.setText(str(lc[1]))
        self.le_state4_intensity.setText(str(lc[2]))

    @VisualizeBase.receiver(channel=26)
    def le_extinction_update(self, value):
        self.le_extinction.setText(str(value))

